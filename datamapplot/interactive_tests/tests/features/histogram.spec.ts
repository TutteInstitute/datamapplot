import { test, expect } from '@playwright/test';
import { DataMapPage } from '../../utils/datamap-page';

test.describe('Histogram Functionality', { tag: '@fast' }, () => {
    let datamap: DataMapPage;

    test.beforeEach(async ({ page }, testInfo) => {
        datamap = new DataMapPage(page);

        // Use minimal fixture generated by Python tests
        await datamap.goto('minimal_histogram.html');
        await datamap.waitForReady(testInfo);
    });

    test('histogram container exists when enabled', async ({ page }) => {
        const histogram = datamap.getHistogram();

        // Try multiple possible selectors for histogram
        const histogramSelectors = [
            '#histogram-container',
            '[class*="histogram"]',
            '.histogram',
            '#histogram',
            'svg.histogram',
        ];

        let found = false;
        for (const selector of histogramSelectors) {
            const element = page.locator(selector);
            if (await element.count() > 0) {
                found = true;
                break;
            }
        }

        expect(found).toBe(true);
    });

    test('histogram is visible', async ({ page }) => {
        const histogram = datamap.getHistogram();
        const isVisible = await histogram.isVisible().catch(() => false);

        if (!isVisible) {
            // Try alternative selectors
            const altHistogram = page.locator('[class*="histogram"], svg').first();
            const altVisible = await altHistogram.isVisible().catch(() => false);

            expect(isVisible || altVisible).toBe(true);
        } else {
            expect(isVisible).toBe(true);
        }
    });

    test('histogram displays bars', async ({ page }) => {
        // Histogram should have rect elements (bars) in SVG
        const bars = page.locator('svg rect, [class*="histogram"] rect, .bar');
        const count = await bars.count();

        // Should have at least some bars
        expect(count).toBeGreaterThan(0);
    });

    test('histogram brush selection works', async ({ page }, testInfo) => {
        if (datamap.isMobile(testInfo)) {
            // Brush selection typically doesn't work well on mobile
            test.skip();
            return;
        }

        const histogram = datamap.getHistogram();
        const box = await histogram.boundingBox();

        if (!box) {
            test.skip();
            return;
        }

        // Perform a brush selection across part of the histogram
        const startX = box.x + box.width * 0.2;
        const endX = box.x + box.width * 0.6;
        const y = box.y + box.height / 2;

        await page.mouse.move(startX, y);
        await page.mouse.down();
        await page.mouse.move(endX, y, { steps: 10 });
        await page.mouse.up();

        await datamap.waitForCanvasStable();

        // Canvas should update to filter points
        const canvas = datamap.getCanvas();
        await expect(canvas).toBeVisible();
    });

    test('histogram selection filters points', async ({ page }, testInfo) => {
        if (datamap.isMobile(testInfo)) {
            test.skip();
            return;
        }

        // Take screenshot before selection
        await datamap.expectCanvasScreenshot('histogram-before-selection.png');

        const histogram = datamap.getHistogram();
        const box = await histogram.boundingBox();

        if (!box) {
            test.skip();
            return;
        }

        // Perform brush selection
        const startX = box.x + box.width * 0.3;
        const endX = box.x + box.width * 0.5;
        const y = box.y + box.height / 2;

        await page.mouse.move(startX, y);
        await page.mouse.down();
        await page.mouse.move(endX, y, { steps: 10 });
        await page.mouse.up();

        await datamap.waitForCanvasStable();

        // Take screenshot after selection
        await datamap.expectCanvasScreenshot('histogram-after-selection.png');
    });

    test('clear histogram filter restores all points', async ({ page }, testInfo) => {
        if (datamap.isMobile(testInfo)) {
            test.skip();
            return;
        }

        const histogram = datamap.getHistogram();
        const box = await histogram.boundingBox();

        if (!box) {
            test.skip();
            return;
        }

        // First make a selection
        const startX = box.x + box.width * 0.3;
        const endX = box.x + box.width * 0.5;
        const y = box.y + box.height / 2;

        await page.mouse.move(startX, y);
        await page.mouse.down();
        await page.mouse.move(endX, y, { steps: 10 });
        await page.mouse.up();

        await datamap.waitForCanvasStable();

        // Now click outside to clear selection (or look for reset button)
        const resetButton = page.locator('button:has-text("Reset"), button:has-text("Clear"), .reset-filter');
        const hasResetButton = await resetButton.count() > 0;

        if (hasResetButton) {
            await resetButton.click();
        } else {
            // Double-click on histogram to reset
            await page.mouse.dblclick(box.x + box.width / 2, y);
        }

        await datamap.waitForCanvasStable();

        // Verify canvas is still functional
        const canvas = datamap.getCanvas();
        await expect(canvas).toBeVisible();
    });
});
