import { test, expect } from '@playwright/test';
import { DataMapPage } from '../../utils/datamap-page';

test.describe('Tooltip Functionality', { tag: '@fast' }, () => {
    let datamap: DataMapPage;

    test.beforeEach(async ({ page }, testInfo) => {
        datamap = new DataMapPage(page);

        // Use minimal fixture generated by Python tests
        await datamap.goto('minimal_tooltip.html');
        await datamap.waitForReady(testInfo);
    });

    test('tooltip element exists in DOM', async ({ page }) => {
        // The tooltip element should exist even if not visible
        const tooltip = datamap.getTooltip();
        await expect(tooltip).toBeAttached();
    });

    test('tooltip appears on point hover', async ({ page }) => {
        // Get canvas center area where points are likely to be
        const size = await datamap.getCanvasSize();
        const centerX = size.width / 2;
        const centerY = size.height / 2;

        // Move to canvas area - tooltip should eventually appear when hovering over a point
        // We'll try multiple positions in a grid pattern to find a point
        let tooltipAppeared = false;

        for (let dx = -50; dx <= 50 && !tooltipAppeared; dx += 25) {
            for (let dy = -50; dy <= 50 && !tooltipAppeared; dy += 25) {
                await datamap.hoverAt(centerX + dx, centerY + dy);
                await page.waitForTimeout(100);

                if (await datamap.isTooltipVisible()) {
                    tooltipAppeared = true;
                }
            }
        }

        expect(tooltipAppeared).toBe(true);
    });

    test('tooltip contains hover text content', async ({ page }) => {
        const size = await datamap.getCanvasSize();
        const centerX = size.width / 2;
        const centerY = size.height / 2;

        // Search for a point and check tooltip content
        let tooltipText = '';

        for (let dx = -50; dx <= 50; dx += 25) {
            for (let dy = -50; dy <= 50; dy += 25) {
                await datamap.hoverAt(centerX + dx, centerY + dy);
                await page.waitForTimeout(100);

                if (await datamap.isTooltipVisible()) {
                    tooltipText = await datamap.getTooltipText();
                    if (tooltipText.length > 0) break;
                }
            }
            if (tooltipText.length > 0) break;
        }

        // Tooltip should contain some text (our fixtures have "Point X" in hover text)
        expect(tooltipText.length).toBeGreaterThan(0);
    });

    test('tooltip disappears when moving away from points', async ({ page }) => {
        const size = await datamap.getCanvasSize();
        const centerX = size.width / 2;
        const centerY = size.height / 2;

        // First find a point and show tooltip
        for (let dx = -50; dx <= 50; dx += 25) {
            for (let dy = -50; dy <= 50; dy += 25) {
                await datamap.hoverAt(centerX + dx, centerY + dy);
                await page.waitForTimeout(100);

                if (await datamap.isTooltipVisible()) {
                    // Now move away to a corner where no points should be
                    await datamap.hoverAt(10, 10);
                    await page.waitForTimeout(300);

                    // Tooltip should be hidden now
                    const stillVisible = await datamap.isTooltipVisible();
                    expect(stillVisible).toBe(false);
                    return;
                }
            }
        }

        // If we couldn't find a point, skip the test
        test.skip();
    });

    test('tooltip does not overflow viewport', async ({ page }) => {
        const size = await datamap.getCanvasSize();

        // Try to trigger tooltip near edges
        const edgePositions = [
            { x: 50, y: size.height / 2 },  // Left edge
            { x: size.width - 50, y: size.height / 2 },  // Right edge
            { x: size.width / 2, y: 50 },  // Top edge
            { x: size.width / 2, y: size.height - 50 },  // Bottom edge
        ];

        for (const pos of edgePositions) {
            await datamap.hoverAt(pos.x, pos.y);
            await page.waitForTimeout(150);

            if (await datamap.isTooltipVisible()) {
                const tooltip = datamap.getTooltip();
                const box = await tooltip.boundingBox();

                if (box) {
                    // Check tooltip stays within viewport
                    expect(box.x).toBeGreaterThanOrEqual(0);
                    expect(box.y).toBeGreaterThanOrEqual(0);
                    expect(box.x + box.width).toBeLessThanOrEqual(size.width + 20); // Small tolerance
                    expect(box.y + box.height).toBeLessThanOrEqual(size.height + 20);
                }
            }
        }
    });
});
