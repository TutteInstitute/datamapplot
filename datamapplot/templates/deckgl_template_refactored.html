<!doctype html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>{{ title }}</title>
    {%- if custom_header %}
    {{ custom_header }}
    {%- endif %}

    {% include 'head_dependencies.html' %}
    {% include 'styles.html' %}
    {%- if custom_css %}
    <style>
      {{ custom_css }}
    </style>
    {%- endif %}
  </head>
  <body>
    {% include 'loading_indicator.html' %}
    <div id="container-box" class="container-box" style="font-family: '{{ font_family }}';">
      {% include 'content_layout.html' %}
    </div>
    {% include 'progress_bars.html' %}
  </body>
  {%- for _, js_src in js_dependency_srcs.items() %}
  <script>
    {{ js_src | safe }}
  </script>
  {%- endfor %}
  <script type="module">
    {# Utility functions #}
    function debounce(func, timeout = 250) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
    }

    async function simpleArrowParser(arrow_bytes) {
      const table = await Arrow.tableFromIPC(arrow_bytes);
      const result = {};
      table.schema.fields.forEach((field) => {
        result[field.name] = table.getChild(field.name).toArray();
      });
      return result;
    }

    function mergeTypedArrays(arrays) {
        let totalLength = arrays.reduce((acc, arr) => acc + arr.length, 0);
        let result = new arrays[0].constructor(totalLength);
        let currentLength = 0;
        for (let arr of arrays) {
            result.set(arr, currentLength);
            currentLength += arr.length;
        }
        return result;
    }

    {% if not inline_data -%}
    function combineTypedTableChunks(tableChunks) {
      tableChunks.sort((a, b) => a.chunkIndex - b.chunkIndex);
      const combinedTable = {};
      Object.keys(tableChunks[0].chunkData).forEach((key) => {
        const arrays = tableChunks.map((chunk) => chunk.chunkData[key]);
        combinedTable[key] = mergeTypedArrays(arrays);
      });
      return combinedTable;
    }

    function combineTableChunks(tableChunks) {
      tableChunks.sort((a, b) => a.chunkIndex - b.chunkIndex);
      const combinedTable = {};
      Object.keys(tableChunks[0].chunkData).forEach((key) => {
        const arrays = tableChunks.map((chunk) => chunk.chunkData[key]);
        combinedTable[key] = arrays.flat();
      });
      return combinedTable;
    }
    {% endif -%}

    if (!("CompressionStream" in window)) {
      throw new Error(
        "Your browser doesn't support the Compression Streams API " +
          "https://developer.mozilla.org/docs/Web/API/Compression_Streams_API#browser_compatibility",
      );
    }

    {# Data encoding setup - inline or file-based #}
    {% if inline_data %}
    const pointDataEncoded = "{{ base64_point_data }}";
    const hoverDataEncoded = "{{ base64_hover_data }}";
    const labelDataEncoded = "{{ base64_label_data }}";
    {% if enable_histogram %}
    const histogramBinDataEncoded = "{{ base64_histogram_bin_data }}";
    const histogramIndexDataEncoded = "{{ base64_histogram_index_data }}";
    {% endif %}
    {% if enable_colormap_selector %}
    const colorDataEncoded = "{{ base64_color_data }}";
    {% endif %}
    {% if edge_bundle %}
    const edgeDataEncoded = "{{ base64_edge_data }}";
    {% endif %}

    {%- include 'worker_inline.js.jinja' %}
    const workerUrl = URL.createObjectURL(parsingWorkerBlob);
    {%- else -%}
    {# File-based data loading #}
    let loadData = false;

    {%- if is_notebook_viewer %}
    const overlay = document.createElement('div');
    overlay.id = 'splash-overlay';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    overlay.style.zIndex = '9999';
    overlay.style.display = 'flex';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';

    const splashWarning = document.createElement('div');
    splashWarning.style.color = 'white';
    splashWarning.style.textAlign = 'center';
    splashWarning.style.maxWidth = '400px';
    splashWarning.style.fontFamily = '{{ title_font_family }}';
    splashWarning.innerHTML = `
      <h2 style="font-size: 24px;">Start Loading Data</h2>
      <h4>Data for this DataMapPlot is stored in files.</h4>
      <p>This requires allowing downloads from your server where the data files are stored.</p>
      <p>Click the button below only if you trust the source.</p>
    `;
    overlay.appendChild(splashWarning);

    const dismissSplashButton = document.createElement('button');
    dismissSplashButton.textContent = 'Load data';
    dismissSplashButton.onclick = () => {
        overlay.style.display = 'none';
        loadData = true;
    };
    dismissSplashButton.style.padding = '10px 20px';
    dismissSplashButton.style.fontSize = '18px';
    dismissSplashButton.style.backgroundColor = 'green';
    dismissSplashButton.style.fontFamily = '{{ title_font_family }}';
    dismissSplashButton.style.color = 'white';
    dismissSplashButton.style.border = 'none';
    dismissSplashButton.style.cursor = 'pointer';
    dismissSplashButton.style.borderRadius = '8px';
    splashWarning.appendChild(dismissSplashButton);
    document.body.appendChild(overlay);

    while (!loadData) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    {% endif %}

    const currentURL = self.location.pathname;
    const directoryPath = currentURL.substring(0, currentURL.lastIndexOf('/') + 1);
    const originURL = self.location.origin + directoryPath;

    const pointDataEncoded = [
      {% for chunk_index in range(n_data_chunks) -%}
      `${originURL}/{{ file_prefix }}_point_data_{{ chunk_index }}.zip`,
      {% endfor -%}
    ];
    const hoverDataEncoded = [
      {% for chunk_index in range(n_data_chunks) -%}
      `${originURL}/{{ file_prefix }}_meta_data_{{ chunk_index }}.zip`,
      {% endfor -%}
    ];
    const labelDataEncoded = [`${originURL}/{{ file_prefix }}_label_data.zip`];
    {% if enable_histogram %}
    const histogramBinDataEncoded = [`${originURL}/{{ file_prefix }}_histogram_bin_data.zip`];
    const histogramIndexDataEncoded = [`${originURL}/{{ file_prefix }}_histogram_index_data.zip`];
    {% endif %}
    {% if enable_colormap_selector %}
    const colorDataEncoded = [
      {% for chunk_index in range(n_data_chunks) -%}
      `${originURL}/{{ file_prefix }}_color_data_{{ chunk_index }}.zip`,
      {% endfor -%}
    ];
    {% endif %}
    {% if edge_bundle %}
    const edgeDataEncoded = [`${originURL}/{{ file_prefix }}_edge_data.zip`];
    {% endif %}

    {%- include 'worker_file.js.jinja' %}
    const workerUrl = URL.createObjectURL(parsingWorkerBlob);
    {%- endif %}

    const searchItemId = "text-search";
    const histogramItemId = "d3histogram-container";
    const selectionItemId = "lasso-select";
    const searchItem = document.getElementById(searchItemId);
    let histogramItem = null;
    
    const container = document.getElementById('deck-container');

    const labelDataWorker = new Worker(workerUrl);
    const pointDataWorker = new Worker(workerUrl);
    const metaDataWorker = new Worker(workerUrl);
    {% if enable_histogram -%}
    const histogramBinDataWorker = new Worker(workerUrl);
    const histogramIndexDataWorker = new Worker(workerUrl);
    {% endif -%}
    {% if enable_colormap_selector -%}
    const colorDataWorker = new Worker(workerUrl);
    {% endif %}
    {% if edge_bundle -%}
    const edgeDataWorker = new Worker(workerUrl);
    {% endif %}

    const datamap = new DataMap({
      container: container,
      bounds: {{ data_bounds }},
      searchItemId: searchItemId,
      lassoSelectionItemId: selectionItemId,      
    });

    function updateProgressBar(id, progress) {
      const progressBar = document.querySelector(`#${id} .datamapplot-progress-bar-fill`);
      const progressText = document.querySelector(`#${id} .datamapplot-progress-bar-text`);
      progressBar.style.width = `${progress}%`;
      progressText.textContent = `${id.replace('-progress', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}: ${progress}%`;
    }

    function checkAllDataLoaded() {
      const progressBars = document.querySelectorAll('.datamapplot-progress-bar-fill');
      const allLoaded = Array.from(progressBars).every(bar => bar.style.width === '100%');
      if (allLoaded) {
        document.getElementById("loading").style.display = "none";
        document.getElementById("progress-container").style.display = "none";
      }
    }

    function loadPointDataLayer() {
      pointDataWorker.postMessage({encodedData: pointDataEncoded, JSONParse: false});

      pointDataWorker.onmessage = async function(event) {
        if (event.data.type === "progress") {
          updateProgressBar('point-data-progress', event.data.progress);
        } else {
          const { data } = event.data;
          {% if inline_data %}
          const pointData = await simpleArrowParser(data);
          {% else %}
          const chunkArray = data.map(async ({ chunkIndex, chunkData }) => {
            return {chunkIndex: chunkIndex, chunkData: await simpleArrowParser(chunkData)};
          });
          const pointData = await Promise.all(chunkArray).then(combineTypedTableChunks);
          {% endif %}
          datamap.addPoints(
            pointData,
            {
              pointSize: {{ point_size }},
              pointOutlineColor: {{ point_outline_color }},
              pointLineWidth: {{ point_line_width }},
              pointHoverColor: {{ point_hover_color }},
              pointLineWidthMaxPixels: {{ point_line_width_max_pixels }},
              pointLineWidthMinPixels: {{ point_line_width_min_pixels }},
              pointRadiusMaxPixels: {{ point_radius_max_pixels }},
              pointRadiusMinPixels: {{ point_radius_min_pixels }},
            }
          );

          document.getElementById("loading").style.display = "none";
          updateProgressBar('point-data-progress', 100);
          checkAllDataLoaded();
          
          {%- if enable_lasso_selection %}
          /* Lasso Selection */
          const lassoSelector = new LassoSelectionTool(
            datamap,
          );
          datamap.lassoSelector = lassoSelector;
          {% endif -%}
        }
      };

      {% if enable_colormap_selector %}
      colorDataWorker.postMessage({encodedData: colorDataEncoded, JSONParse: false});

      colorDataWorker.onmessage = async function(event) {
        if (event.data.type === "progress") {
          updateProgressBar('color-data-progress', event.data.progress);
        } else {
          const { data } = event.data;
          {% if inline_data %}
          const colorData = await simpleArrowParser(data);
          {% else %}
          const chunkArray = data.map(async ({ chunkIndex, chunkData }) => {
            return {chunkIndex: chunkIndex, chunkData: await simpleArrowParser(chunkData)};
          });
          const colorData = await Promise.all(chunkArray).then(combineTypedTableChunks);
          {% endif %}
          const colormapListing = {{ colormap_data }};
          const colormapSelector = ColormapSelector.create({
            colorData: colorData,
            colormaps: colormapListing,
            datamap: datamap,
            containerId: 'colormap-selector-container',
            {% if colormap_selector_width -%}
            width: {{ colormap_selector_width }},
            {% endif -%}
            {% if colormap_selector_height -%}
            height: {{ colormap_selector_height }},
            {% endif -%}
          });
          updateProgressBar('color-data-progress', 100);
          checkAllDataLoaded();
        }
      };
      {% endif %}

      {% if edge_bundle %}
      edgeDataWorker.postMessage({encodedData: edgeDataEncoded, JSONParse: true});

      edgeDataWorker.onmessage = async function(event) {
        if (event.data.type === "progress") {
          updateProgressBar('edge-data-progress', event.data.progress);
        } else {
          const { data } = event.data;
          {% if inline_data -%}
          const edgeData = data;
          {% else -%}
          const edgeData = data[0].chunkData;
          {% endif %}
          datamap.addEdges(edgeData, {
            lineColor: {{ edge_line_color }},
            lineWidth: {{ edge_line_width }},
          });
          updateProgressBar('edge-data-progress', 100);
          checkAllDataLoaded();
        }
      };
      {% endif %}
    }

    function loadLabelDataLayer() {
      labelDataWorker.postMessage({encodedData: labelDataEncoded, JSONParse: true});
      labelDataWorker.onmessage = async function(event) {
        if (event.data.type === "progress") {
          updateProgressBar('label-data-progress', event.data.progress);
        } else {
          const { data } = event.data;
          {% if inline_data -%}
          const labelData = data;
          {% else -%}
          const labelData = data[0].chunkData;
          {% endif %}
          const labelRenderingOptions = {
            collisionBoxSize: {{ collision_box_size }},
            maxLabelsPerCluster: {{ max_labels_per_cluster }},
            textMinPixelSize: {{ text_min_pixel_size }},
            textMaxPixelSize: {{ text_max_pixel_size }},
            textOutlineWidth: {{ text_outline_width }},
            textOutlineColor: {{ text_outline_color }},
            textBackgroundColor: {{ text_background_color }},
            lineColor: {{ label_line_color }},
            {%- if cluster_boundary_polygons %}
            clusterBoundaryPolygons: true,
            clusterBoundaryLineColor: {{ cluster_boundary_line_color }},
            clusterBoundaryPolygonFillOpacity: {{ cluster_boundary_polygon_fill_opacity }},
            clusterBoundaryLineWidth: {{ cluster_boundary_line_width }},
            clusterBoundaryLineDash: {{ cluster_boundary_line_dash }},
            {%- endif %}
            {%- if use_gzip_for_saved_label_data %}
            useGzipForSavedLabelData: true,
            {%- endif %}
          };
          datamap.addLabels(labelData, labelRenderingOptions);
          updateProgressBar('label-data-progress', 100);
          checkAllDataLoaded();

          {%- if enable_topic_tree %}
          const topicTree = TopicTree.create({
            datamap: datamap,
            containerId: "topic-tree-container",
          });
          topicTree.updateTree(getVisibleTextData(datamap.deck.viewManager.getViewState('map')));
          datamap.topicTree = topicTree;
          datamap.deck.setProps({
            onViewStateChange: ({ viewState }) => {
              debounce(topicTree.updateTree(getVisibleTextData(viewState)), 500);
            }
          });
          {% endif -%}
        }
      };
    }

    function loadMetaData() {
      metaDataWorker.postMessage({encodedData: hoverDataEncoded, JSONParse: true});

      metaDataWorker.onmessage = async function(event) {
        if (event.data.type === "progress") {
          updateProgressBar('meta-data-progress', event.data.progress);
        } else {
          const { data } = event.data;
          {% if inline_data -%}
          const hoverData = data;
          {% else -%}
          const hoverData = combineTableChunks(data);
          {% endif %}
          datamap.addMetaData(hoverData, {
            hoverTextFunction: {{ hover_text }},
            {%- if click_url_function %}
            clickURLFunction: {{ click_url_function }},
            {%- endif %}
          });
          updateProgressBar('meta-data-progress', 100);
          checkAllDataLoaded();
        }
      };
    }

    {%- if enable_histogram %}

    function loadHistogramBinData() {
      return new Promise((resolve, reject) => {
        histogramBinDataWorker.postMessage({encodedData: histogramBinDataEncoded, JSONParse: true});

        histogramBinDataWorker.onmessage = async function(event) {
          if (event.data.type === "progress") {
            updateProgressBar('histogram-bin-data-progress', event.data.progress);
          } else {
            const { data } = event.data;
            {% if inline_data -%}
            const histogramBinData = data;
            {% else -%}
            const histogramBinData = data[0].chunkData;
            {% endif -%}
            resolve(histogramBinData);
            updateProgressBar('histogram-bin-data-progress', 100);
            checkAllDataLoaded();
          }
        };
      });
    }

    function loadHistogramIndexData() {
      return new Promise((resolve, reject) => {
        histogramIndexDataWorker.postMessage({encodedData: histogramIndexDataEncoded, JSONParse: false});

        histogramIndexDataWorker.onmessage = async function(event) {
          if (event.data.type === "progress") {
            updateProgressBar('histogram-index-data-progress', event.data.progress);
          } else {
            const { data } = event.data;
            {% if inline_data -%}
            const histogramIndexData = simpleArrowParser(data);
            {% else -%}
            const histogramIndexData = simpleArrowParser(data[0].chunkData);
            {% endif -%}
            resolve(histogramIndexData);
            updateProgressBar('histogram-index-data-progress', 100);
            checkAllDataLoaded();
          }
        };
      });
    }

    function loadHistogramData() {
      const chartSelectionCallback = chartSelectedIndices => {
        // Update data manager
        if (chartSelectedIndices === null) {
          datamap.removeSelection(histogramItemId);
        } else {
          datamap.addSelection(chartSelectedIndices, histogramItemId);
        }
      };

      Promise.all([loadHistogramBinData(), loadHistogramIndexData()]).then(([histogramBinData, histogramIndexData]) => {
        const histogramData = { rawBinData: histogramBinData, rawIndexData: histogramIndexData };
        histogramItem = D3Histogram.create({
          data: histogramData, 
          chartContainerId: histogramItemId,
          {%- if histogram_width %}
          chartWidth: {{ histogram_width }},
          {%- endif %}
          {%- if histogram_height %}
          chartHeight: {{ histogram_height }},
          {%- endif %}
          {%- if histogram_bin_count %}
          binCount: {{ histogram_bin_count }},
          {%- endif %}
          {%- if histogram_title %}
          title: "{{ histogram_title }}",
          {%- endif %}
          enableClickPersistence: {{ histogram_enable_click_persistence|lower }},
          {%- if histogram_bin_fill_color %}
          binDefaultFillColor: "{{ histogram_bin_fill_color }}",
          {%- endif %}
          {%- if histogram_bin_selected_fill_color %}
          binSelectedFillColor: "{{ histogram_bin_selected_fill_color }}",
          {%- endif %}
          {%- if histogram_bin_unselected_fill_color %}
          binUnselectedFillColor: "{{ histogram_bin_unselected_fill_color }}",
          {%- endif %}
          {%- if histogram_bin_context_fill_color %}
          binContextFillColor: "{{ histogram_bin_context_fill_color }}",
          {%- endif %}
          {%- if histogram_log_scale %}
          logScale: {{ histogram_log_scale|lower }},
          {%- endif %}
          chartSelectionCallback: chartSelectionCallback,
        });

        datamap.connectHistogram(histogramItem);
      });
    }
    {% endif -%}

    {% if enable_topic_tree %}
    function isBoundsVisible({bounds, viewState}) {
        const {width, height, longitude, latitude, zoom} = viewState;
    
        const Viewport = new deck.WebMercatorViewport({
            width,
            height,
            longitude,
            latitude,
            zoom,
        })
    
        const viewBounds = [
            [0,0],
            [width, height],
        ];
    
        const minBounds = Viewport.project([bounds[0], bounds[2]]);
        const maxBounds = Viewport.project([bounds[1], bounds[3]]);
    
        return (
            ((minBounds[0] >= 0 && minBounds[0] <= width) || (maxBounds[0] >= 0 && maxBounds[0] <= width)) &&
            ((minBounds[1] >= 0 && minBounds[1] <= height) || (maxBounds[1] >= 0 && maxBounds[1] <= height))
        );
    };
          
    function getVisibleTextData(viewState) {
        if (datamap.labelData) {
            const visibleData = datamap.labelData.filter((d) => {
                return isBoundsVisible({
                    bounds: d.bounds,
                    viewState: viewState,
                });
            });
            return visibleData;
        };
    };
    
    {% endif %}
      
    {%- if background_image -%}
    datamap.addBackgroundImage("{{ background_image }}", {{ background_image_bounds }});
    {%- endif %}

    {%- if enable_colormap_selector %}
    {% endif -%}

    loadPointDataLayer();
    loadLabelDataLayer();
    loadMetaData();
    {%- if enable_histogram %}
    loadHistogramData();
    {% endif -%}
    {%- if enable_api_tooltip %}
    const tooltip = new DynamicTooltipManager(
      datamap,
      {
        {%- if tooltip_identifier_js %}getIdentifier: {{ tooltip_identifier_js }},{% endif -%}
        fetchData: {{ tooltip_fetch_js }},
        formatContent: {{ tooltip_format_js }},
        formatLoading: {{ tooltip_loading_js }},
        formatError: {{ tooltip_error_js }},
      }
    );
    {% endif -%}
    {% if custom_js %}
    {{ custom_js }}
    {% endif -%}
  </script>
</html>
